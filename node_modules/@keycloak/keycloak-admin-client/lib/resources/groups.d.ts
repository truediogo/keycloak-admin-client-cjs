import type { KeycloakAdminClient } from "../client.js";
import type GroupRepresentation from "../defs/groupRepresentation.js";
import type { ManagementPermissionReference } from "../defs/managementPermissionReference.js";
import type MappingsRepresentation from "../defs/mappingsRepresentation.js";
import type RoleRepresentation from "../defs/roleRepresentation.js";
import type { RoleMappingPayload } from "../defs/roleRepresentation.js";
import type UserRepresentation from "../defs/userRepresentation.js";
import Resource from "./resource.js";
interface Query {
    q?: string;
    search?: string;
    exact?: boolean;
}
interface PaginatedQuery {
    first?: number;
    max?: number;
}
interface SummarizedQuery {
    briefRepresentation?: boolean;
}
export type GroupQuery = Query & PaginatedQuery & SummarizedQuery;
export type SubGroupQuery = PaginatedQuery & SummarizedQuery & {
    parentId: string;
};
export interface GroupCountQuery {
    search?: string;
    top?: boolean;
}
export declare class Groups extends Resource<{
    realm?: string;
}> {
    find: (payload?: (Query & PaginatedQuery & SummarizedQuery & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<GroupRepresentation[]>;
    create: (payload?: (GroupRepresentation & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<{
        id: string;
    }>;
    updateRoot: (payload?: (GroupRepresentation & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<void>;
    /**
     * Single user
     */
    findOne: (payload?: ({
        id: string;
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<GroupRepresentation | undefined>;
    update: (query: {
        id: string;
    } & {
        realm?: string | undefined;
    }, payload: GroupRepresentation) => Promise<void>;
    del: (payload?: ({
        id: string;
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<void>;
    count: (payload?: (GroupCountQuery & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<{
        count: number;
    }>;
    /**
     * Set or create child.
     * This will just set the parent if it exists. Create it and set the parent if the group doesn’t exist.
     * @deprecated Use `createChildGroup` or `updateChildGroup` instead.
     */
    setOrCreateChild: (query: {
        id: string;
    } & {
        realm?: string | undefined;
    }, payload: GroupRepresentation) => Promise<{
        id: string;
    }>;
    /**
     * Creates a child group on the specified parent group. If the group already exists, then an error is returned.
     */
    createChildGroup: (query: {
        id: string;
    } & {
        realm?: string | undefined;
    }, payload: Omit<GroupRepresentation, "id">) => Promise<{
        id: string;
    }>;
    /**
     * Updates a child group on the specified parent group. If the group doesn’t exist, then an error is returned.
     * Can be used to move a group from one parent to another.
     */
    updateChildGroup: (query: {
        id: string;
    } & {
        realm?: string | undefined;
    }, payload: GroupRepresentation) => Promise<void>;
    /**
     * Finds all subgroups on the specified parent group matching the provided parameters.
     */
    listSubGroups: (payload?: (PaginatedQuery & SummarizedQuery & {
        parentId: string;
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<GroupRepresentation[]>;
    /**
     * Members
     */
    listMembers: (payload?: ({
        id: string;
        first?: number | undefined;
        max?: number | undefined;
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<UserRepresentation[]>;
    /**
     * Role mappings
     * https://www.keycloak.org/docs-api/11.0/rest-api/#_role_mapper_resource
     */
    listRoleMappings: (payload?: ({
        id: string;
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<MappingsRepresentation>;
    addRealmRoleMappings: (payload?: ({
        id: string;
        roles: RoleMappingPayload[];
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<void>;
    listRealmRoleMappings: (payload?: ({
        id: string;
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<RoleRepresentation[]>;
    delRealmRoleMappings: (payload?: ({
        id: string;
        roles: RoleMappingPayload[];
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<void>;
    listAvailableRealmRoleMappings: (payload?: ({
        id: string;
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<RoleRepresentation[]>;
    listCompositeRealmRoleMappings: (payload?: ({
        id: string;
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<RoleRepresentation[]>;
    /**
     * Client role mappings
     * https://www.keycloak.org/docs-api/11.0/rest-api/#_client_role_mappings_resource
     */
    listClientRoleMappings: (payload?: ({
        id: string;
        clientUniqueId: string;
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<RoleRepresentation[]>;
    addClientRoleMappings: (payload?: ({
        id: string;
        clientUniqueId: string;
        roles: RoleMappingPayload[];
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<void>;
    delClientRoleMappings: (payload?: ({
        id: string;
        clientUniqueId: string;
        roles: RoleMappingPayload[];
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<void>;
    listAvailableClientRoleMappings: (payload?: ({
        id: string;
        clientUniqueId: string;
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<RoleRepresentation[]>;
    listCompositeClientRoleMappings: (payload?: ({
        id: string;
        clientUniqueId: string;
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<RoleRepresentation[]>;
    /**
     * Authorization permissions
     */
    updatePermission: (query: {
        id: string;
    } & {
        realm?: string | undefined;
    }, payload: ManagementPermissionReference) => Promise<ManagementPermissionReference>;
    listPermissions: (payload?: ({
        id: string;
    } & {
        realm?: string | undefined;
    }) | undefined, options?: Pick<import("./agent.js").RequestArgs, "catchNotFound"> | undefined) => Promise<ManagementPermissionReference>;
    constructor(client: KeycloakAdminClient);
}
export {};
